#pragma once

// Auto-generated from wind.vert.glsl
// Do not edit this file manually

const char* const WIND_VERTEX_SHADER = "#version 460 core\n\n#extension GL_ARB_separate_shader_objects : enable\n#extension GL_ARB_shading_language_420pack : enable\n\n#define INSTANCES_COUNT 4\n\nlayout(location=0) in vec3 aPos;\nlayout(location=1) in vec3 aNormal;\nlayout(location=2) in vec2 aTexCoords;\nlayout(location=5) in mat4 aInstanceMatrix;\nlayout(location=9) in uint aInstanceId;\nlayout(location=10) in vec4 aColor;\n\nlayout(std140, binding=0) uniform Globals {\n    mat4 uProj;\n    mat4 uView;\n    mat4 uModel;\n\n    float uTime;\n    float uWaveAmp;\n    float uWaveSpeed;\n    int uPickedInstanceID;\n\n    vec4 uColor;\n\n    vec3 uBoundsMin;\n    float deltaX;\n    vec3 uBoundsMax;\n    float deltaY;\n\n    vec4 InstanceOffset[ INSTANCES_COUNT ];\n};\n\nlayout(location=0) out vec3 FragPos;\nlayout(location=1) out vec2 TexCoords;\nlayout(location=2) out uint InstanceID;\nlayout(location=3) out float layerIndex;\nlayout(location=4) out float heightFactor;\nlayout(location=5) out vec4 ColorFromVertex;\n\nvoid main() {\n\n    FragPos = vec3(aInstanceMatrix * vec4(aPos, 1.0));\n\n    vec3 modelPos = aPos;\n    float heightRatio = ( modelPos.y - uBoundsMin.y ) / ( uBoundsMax.y - uBoundsMin.y );\n    heightRatio = clamp( heightRatio, 0.0, 1.0 );\n\n    layerIndex = step( 0.33, heightRatio) + step( 0.66, heightRatio );\n    heightFactor = heightRatio;\n\n    float xPositionFactor = modelPos.x / ( uBoundsMax.x - uBoundsMin.x);\n    xPositionFactor = abs( xPositionFactor );\n    xPositionFactor = clamp( xPositionFactor, 0.0, 1.0 );\n\n    float distanceAmplifier = mix( 0.1, 1.0, xPositionFactor );\n\n    float waveAmplitudeY, frequencyY, phaseOffsetY;\n\n    if ( layerIndex == 0.0 ) {\n        waveAmplitudeY = uWaveAmp * 0.5 * distanceAmplifier;\n        frequencyY = 0.8;\n        phaseOffsetY = 0.0;\n    } else if ( layerIndex == 1.0 ) {\n        waveAmplitudeY = uWaveAmp * 1.0 * distanceAmplifier;\n        frequencyY = 1.2;\n        phaseOffsetY = 0.52;\n    } else {\n        waveAmplitudeY = uWaveAmp * 1.5 * distanceAmplifier;\n        frequencyY = 1.8;\n        phaseOffsetY = 1.05;\n    }\n\n    float time = uTime * uWaveSpeed;\n\n    float waveY_primary = sin( time * frequencyY + modelPos.x * 1.5 + modelPos.z * 0.8 + phaseOffsetY );\n\n    float waveY_secondary = sin( time * frequencyY * 1.7 + modelPos.x * 0.5 + modelPos.z * 1.2 ) * 0.3;\n\n    float waveY_detail = sin( time * frequencyY * 3.2 + modelPos.x * 2.1 + modelPos.z * 1.9 ) * 0.15;\n\n    float totalWaveY = ( waveY_primary + waveY_secondary + waveY_detail ) * waveAmplitudeY;\n\n    FragPos.y += totalWaveY;\n\n    ColorFromVertex = aColor;\n    InstanceID = aInstanceId;\n    TexCoords = aTexCoords;\n\n    int instanceIndex = int(aInstanceId) - 1;\n    if (instanceIndex >= 0 && instanceIndex < 4) {\n        FragPos.x += InstanceOffset[instanceIndex].x  * TexCoords.x;\n        FragPos.y -= InstanceOffset[instanceIndex].y  * TexCoords.x;\n    }\n\n    gl_Position = uProj * uView * vec4(FragPos, 1.0);\n}";
