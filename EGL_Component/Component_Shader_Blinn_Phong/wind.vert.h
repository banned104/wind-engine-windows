#pragma once
inline const char* WIND_VERTEX_SHADER = "#version 310 es\n//precision mediump float;\nprecision highp float;\n\n#define INSTANCES_COUNT 4\n\n// struct InstanceOffset {\n//     float deltaX;\n//     float deltaY;\n//     float _padding1;  // 为了对齐\n//     float _padding2;  // 为了对齐\n// };\n\nlayout(location=0) in vec3 aPos;\nlayout(location=1) in vec3 aNormal;\nlayout(location=2) in vec2 aTexCoords;\nlayout(location=5) in mat4 aInstanceMatrix;\nlayout(location=9) in uint aInstanceId;  // 实例ID\nlayout(location=10) in vec4 aColor;      // 实例颜色\n\n// UBO: 包含 MVP 矩阵\nlayout(std140, binding=0) uniform Globals {\n    mat4 uProj;\n    mat4 uView;\n    mat4 uModel;\n\n    float uTime;\n    float uWaveAmp;\n    float uWaveSpeed;\n    int uPickedInstanceID;\n\n    vec4 uColor;\n\n    // 传递包围盒信息\n    vec3 uBoundsMin;\n    float deltaX;  // 保留用于兼容性\n    vec3 uBoundsMax;\n    float deltaY;  // 保留用于兼容性\n\n    // 每个实例的独立偏移数组\n    // float instanceOffsetsX[INSTANCES_COUNT];  // INSTANCES_COUNT = 4\n    // float instanceOffsetsY[INSTANCES_COUNT];\n    // float _padding1[INSTANCES_COUNT];  // 用于对齐\n    // float _padding2[INSTANCES_COUNT];  // 用于对齐\n\n    // struct InstanceOffset[ INSTANCES_COUNT ];\n    vec4 InstanceOffset[ INSTANCES_COUNT ];\n};\n\n\n\n// 输出到片段着色器\nlayout(location=0) out vec3 FragPos;   // 片段在世界空间中的位置\nlayout(location=1) out vec2 TexCoords; // 纹理坐标\nlayout(location=2) out uint InstanceID;\nlayout(location=3) out float layerIndex;       // 层索引\nlayout(location=4) out float heightFactor;     // 高度因子\nlayout(location=5) out vec4 ColorFromVertex;\n\nuniform sampler2D vertexMovementTexture;\n\n\nvoid main() {\n    // 将顶点位置和法线变换到世界空间\n    FragPos = vec3(aInstanceMatrix * vec4(aPos, 1.0));\n    // 注意：法线需要用逆转置矩阵变换以避免非等比缩放导致的问题\n    // 为简化，这里我们假设 uModel 没有非等比缩放\n    // Normal = mat3(transpose(inverse(aInstanceMatrix))) * aNormal;\n    \n\n    /*------------------------------------------ 基本波动 ------------------------------------------*/\n    // 根据包围盒计算高度因子 用于判断层索引\n    vec3 modelPos = aPos;\n    float heightRatio = ( modelPos.y - uBoundsMin.y ) / ( uBoundsMax.y - uBoundsMin.y );\n    heightRatio = clamp( heightRatio, 0.0, 1.0 );\n\n    // 根据高度确定层索引 0[0-0.33), 1[0.33-0.66), 2[0.66-1]\n    layerIndex = step( 0.33, heightRatio) + step( 0.66, heightRatio );\n    heightFactor = heightRatio;\n\n    // 计算X轴位置因子 模型从X=0延伸至X正方形\n    float xPositionFactor = modelPos.x / ( uBoundsMax.x - uBoundsMin.x);\n    xPositionFactor = clamp( xPositionFactor, 0.0, 1.0 );\n\n    // 基于X轴位置确定渐变强度: x轴坐标越大  振动越强\n    float distanceAmplifier = mix( 0.1, 1.0, xPositionFactor );     // 从 10% ~ 100% 的振动强度\n    \n    // 为每层设置不同的Y轴振动参数\n    float waveAmplitudeY, frequencyY, phaseOffsetY;\n\n    if ( layerIndex == 0.0 ) {      // 模型三层的最底层 - 稳重振动\n        waveAmplitudeY = uWaveAmp * 0.5 * distanceAmplifier;        // 小振幅\n        frequencyY = 0.8;                                           // 低频率\n        phaseOffsetY = 0.0;                                         // 无相位偏移\n        \n    } else if ( layerIndex == 1.0 ) { // 中层 - 中等振动\n        waveAmplitudeY = uWaveAmp * 1.0 * distanceAmplifier;        // 中等振幅\n        frequencyY = 1.2;                                           // 中等频率\n        phaseOffsetY = 0.52;                                        // π/6 相位偏移\n        \n    } else {                        // 顶层 - 活跃振动\n        waveAmplitudeY = uWaveAmp * 1.5 * distanceAmplifier;        // 大振幅\n        frequencyY = 1.8;                                           // 高频率\n        phaseOffsetY = 1.05;                                        // π/3 相位偏移\n    }\n    // 创建复杂的Y轴波动模式\n    float time = uTime * uWaveSpeed;\n    \n    // 主要波动：基于时间和XZ位置的组合\n    float waveY_primary = sin( time * frequencyY + modelPos.x * 1.5 + modelPos.z * 0.8 + phaseOffsetY );\n    \n    // 次要波动：添加更自然的随机性\n    float waveY_secondary = sin( time * frequencyY * 1.7 + modelPos.x * 0.5 + modelPos.z * 1.2 ) * 0.3;\n    \n    // 微细波动：模拟微风效果\n    float waveY_detail = sin( time * frequencyY * 3.2 + modelPos.x * 2.1 + modelPos.z * 1.9 ) * 0.15;\n    \n    // 合成最终的Y轴偏移\n    float totalWaveY = ( waveY_primary + waveY_secondary + waveY_detail ) * waveAmplitudeY;\n    \n    // 只在Y轴方向应用振动\n    FragPos.y += totalWaveY;\n\n/*------------------------------------------ 整体随触控运动 ------------------------------------------*/\n    ColorFromVertex = aColor;   // 传递颜色\n    InstanceID = aInstanceId;\n    TexCoords = aTexCoords;\n\n    // if ( int(aInstanceId) == uPickedInstanceID  ) {\n    //     // 选中实例时，根据累积的deltaX和deltaY进行偏移\n    //     FragPos.x += deltaX;\n    //     FragPos.y -= deltaY;  // 注意Y轴方向，触摸屏坐标系与OpenGL坐标系相反\n    // }\n\n    // 应用每个实例的独立偏移\n    int instanceIndex = int(aInstanceId) - 1;  // 实例ID从1开始，数组索引从0开始\n    if (instanceIndex >= 0 && instanceIndex < 4) {\n        FragPos.x += InstanceOffset[instanceIndex].x  * TexCoords.x;    // 朝向屏幕的方向是X轴正方向 X坐标值越大移动距离越大 也就实现了出风口不动\n        FragPos.y -= InstanceOffset[instanceIndex].y  * TexCoords.x;  \n    }\n\n    gl_Position = uProj * uView * vec4(FragPos, 1.0);\n}";
