#pragma once
inline const char* WIND_FRAGMENT_SHADER = "#version 310 es\n//precision mediump float;\nprecision highp float;\n#define INSTANCES_COUNT 4\n// struct InstanceOffset {\n//     float deltaX;\n//     float deltaY;\n//     float _padding1;  // 为了对齐\n//     float _padding2;  // 为了对齐\n// };\n\n// 从顶点着色器传入的、经过插值的数据\nlayout(location=0) in vec3 FragPos;\nlayout(location=1) in vec2 TexCoords;\nlayout(location=2) flat in uint InstanceID;\nlayout(location=3) in float layerIndex;       // 层索引\nlayout(location=4) in float heightFactor;     // 高度因子\nlayout(location=5) in vec4 ColorFromVertex;\n\nlayout(location=0) out vec4 FragColor;\n\nlayout(std140, binding=0) uniform Globals {\n    mat4 uProj;\n    mat4 uView;\n    mat4 uModel;\n\n    float uTime;\n    float uWaveAmp;\n    float uWaveSpeed;\n    int uPickedInstanceID;\n\n    vec4 uColor;\n\n    // 传递包围盒信息\n    vec3 uBoundsMin;\n    float deltaX;  // 保留用于兼容性\n    vec3 uBoundsMax;\n    float deltaY;  // 保留用于兼容性\n\n    // 每个实例的独立偏移数组\n    // float instanceOffsetsX[4];  // INSTANCES_COUNT = 4\n    // float instanceOffsetsY[4];\n    // float _padding1[4];  // 用于对齐\n    // float _padding2[4];  // 用于对齐\n\n    // struct InstanceOffset[ INSTANCES_COUNT ];\n    vec4 InstanceOffset[ INSTANCES_COUNT ];\n};\n\n// 材质结构体，现在包含多种纹理\nstruct Material {\n    sampler2D texture_diffuse1;\n    sampler2D texture_diffuse2;\n    sampler2D texture_diffuse3;\n};\nuniform Material material;\n\nvoid main() {\n\n    vec4 texColor;\n    // 优化：预计算时间偏移，避免每片元执行mod运算\n    float timeOffset = uTime * 0.1;\n    vec2 moving_coords = vec2(TexCoords.x - timeOffset, TexCoords.y);\n\n    // 优化：使用纹理数组替代分支，减少分支预测失败\n    // 但由于当前使用单独的纹理，保持原分支但优化判断\n    int layerIdx = int(layerIndex + 0.5); // 四舍五入到最近整数\n    if (layerIdx == 0) {\n        texColor = texture(material.texture_diffuse1, moving_coords);\n    } else if (layerIdx == 1) {\n        texColor = texture(material.texture_diffuse2, moving_coords);\n    } else {\n        texColor = texture(material.texture_diffuse3, moving_coords);\n    }\n\n    // 优化alpha裁剪判断，减少计算量\n    if (texColor.r < 0.1 || texColor.g < 0.1 || texColor.b < 0.1) {\n        discard;\n    }\n\n    // 使用快速亮度计算\n    float brightness = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    texColor.a = smoothstep(0.0, 0.7, brightness);\n\n    // 拾取高亮效果\n    if (abs(float(uPickedInstanceID) - float(InstanceID)) < 0.01) {\n        texColor.r -= deltaX * 0.1;\n        texColor.g -= deltaY * 0.1;\n        texColor.b -= deltaX * 0.1;\n    }\n\n    FragColor = texColor;\n}\n";
